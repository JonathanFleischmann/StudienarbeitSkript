CREATE USER C##Benutzer IDENTIFIED BY saqvizsanqoxsizRe9;
GRANT CONNECT TO C##Benutzer;
GRANT CREATE SESSION TO C##Benutzer;
GRANT CREATE TRIGGER TO C##Benutzer;
GRANT CREATE TABLE TO C##Benutzer;
GRANT CREATE SEQUENCE TO C##Benutzer;
GRANT CREATE VIEW TO C##Benutzer;
GRANT CREATE PROCEDURE TO C##Benutzer;
GRANT CREATE SYNONYM TO C##Benutzer;
GRANT UNLIMITED TABLESPACE TO C##Benutzer;
ALTER USER C##Benutzer QUOTA UNLIMITED ON USERS;

CREATE USER GTFSUSER IDENTIFIED BY inf22;
GRANT CONNECT TO GTFSUSER;
GRANT CREATE SESSION TO GTFSUSER;
GRANT CREATE TRIGGER TO GTFSUSER;
GRANT CREATE TABLE TO GTFSUSER;
GRANT CREATE SEQUENCE TO GTFSUSER;
GRANT CREATE VIEW TO GTFSUSER;
GRANT CREATE PROCEDURE TO GTFSUSER;
GRANT CREATE SYNONYM TO GTFSUSER;
GRANT UNLIMITED TABLESPACE TO GTFSUSER;
ALTER USER GTFSUSER QUOTA UNLIMITED ON USERS;

SELECT * FROM dba_users WHERE username = 'C##Benutzer';

SELECT sys_context('USERENV', 'CON_NAME') AS pdb_name FROM dual;



SELECT pdb_id, pdb_name, status FROM cdb_pdbs;

ALTER SESSION SET CONTAINER = XEPDB1;
ALTER SESSION SET CONTAINER = CDB$ROOT;

SELECT * FROM USER_SYS_PRIVS;

SELECT * FROM dba_sys_privs WHERE grantee = 'C##Benutzer';

SELECT tablespace_name FROM dba_tablespaces;

SELECT s.sid, s.serial#, t.xid, s.username, s.status FROM v$transaction t JOIN v$session s ON t.ses_addr = s.saddr;

ROLLBACK;

COMMIT;


CREATE TABLE agency (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR2(100) UNIQUE NOT NULL,
    url VARCHAR2(100)
);

CREATE TABLE route (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR2(200) NOT NULL,
    short_name VARCHAR2(10) NOT NULL,
    type VARCHAR2(50),
    description VARCHAR2(400),
    agency_id NUMBER NOT NULL,
    CONSTRAINT unique_route UNIQUE (name, short_name, agency_id),
    CONSTRAINT fk_agency FOREIGN KEY (agency_id) REFERENCES agency(id) ON DELETE CASCADE
);

CREATE TABLE weekdays (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    monday NUMBER(1) NOT NULL CHECK (monday IN (0, 1)),
    tuesday NUMBER(1) NOT NULL CHECK (tuesday IN (0, 1)),
    wednesday NUMBER(1) NOT NULL CHECK (wednesday IN (0, 1)),
    thursday NUMBER(1) NOT NULL CHECK (thursday IN (0, 1)),
    friday NUMBER(1) NOT NULL CHECK (friday IN (0, 1)),
    saturday NUMBER(1) NOT NULL CHECK (saturday IN (0, 1)),
    sunday NUMBER(1) NOT NULL CHECK (sunday IN (0, 1)),
    CONSTRAINT unique_weekdays UNIQUE (monday, tuesday, wednesday, thursday, friday, saturday, sunday)
);

CREATE TABLE period (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    weekdays_id NUMBER NOT NULL,
    CONSTRAINT unique_period UNIQUE (start_date, end_date, weekdays_id),
    CONSTRAINT fk_weekdays FOREIGN KEY (weekdays_id) REFERENCES weekdays(id) ON DELETE CASCADE,
    CONSTRAINT check_dates CHECK (start_date <= end_date)
);

CREATE OR REPLACE TRIGGER period_ensure_date_with_default_time
    BEFORE INSERT OR UPDATE ON period
    FOR EACH ROW
BEGIN
    :NEW.start_date := TRUNC(:NEW.start_date);
    :NEW.end_date := TRUNC(:NEW.end_date);
END;
-- nur das Datum ist bei den Spalten relevant, die Uhrzeit wird auf den default-Wert gesetzt

CREATE TABLE trip (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    route_id NUMBER NOT NULL,
    period_id NUMBER NOT NULL,
    start_time TIMESTAMP NOT NULL,
    CONSTRAINT unique_trip UNIQUE (route_id, period_id, start_time),
    CONSTRAINT fk_route FOREIGN KEY (route_id) REFERENCES route(id) ON DELETE CASCADE,
    CONSTRAINT fk_period FOREIGN KEY (period_id) REFERENCES period(id) ON DELETE CASCADE
);
-- nur die Uhrzeit ist bei den Spalten relevant, das Datum wird auf den 01.01.1970 gesetzt

CREATE TABLE deviation (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    deviation_date DATE UNIQUE NOT NULL
);

CREATE OR REPLACE TRIGGER deviation_ensure_date_with_default_time
    BEFORE INSERT OR UPDATE ON exception_table
    FOR EACH ROW
BEGIN
    :NEW.exception_date := TRUNC(:NEW.exception_date);
END;
-- nur das Datum ist bei den Spalten relevant, die Uhrzeit wird auf den default-Wert gesetzt

CREATE TABLE trip_deviation (
    trip_id NUMBER NOT NULL,
    deviation_id NUMBER NOT NULL,                                
    CONSTRAINT pk_trip_deviation PRIMARY KEY (trip_id, deviation_id),
    CONSTRAINT fk_trip_in_trip_deviation FOREIGN KEY (trip_id) REFERENCES trip(id) ON DELETE CASCADE,
    CONSTRAINT fk_deviation FOREIGN KEY (deviation_id) REFERENCES deviation(id) ON DELETE CASCADE
);

CREATE TABLE location_type (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    type VARCHAR2(50) UNIQUE NOT NULL
);

CREATE TABLE traffic_centre (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR2(100),
    location_type_id NUMBER NOT NULL,
    latitude NUMBER(20, 15) NOT NULL,
    longitude NUMBER(20, 15) NOT NULL,
    CONSTRAINT unique_traffic_centre UNIQUE (latitude, longitude),
    CONSTRAINT fk_location_type_in_traffic_centre FOREIGN KEY (location_type_id) REFERENCES location_type(id)
);

CREATE TABLE traffic_point (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR2(100),
    location_type_id NUMBER,
    latitude NUMBER(20, 15) NOT NULL,
    longitude NUMBER(20, 15) NOT NULL,
    traffic_centre_id NUMBER,
    CONSTRAINT unique_traffic_point UNIQUE (latitude, longitude),
    CONSTRAINT fk_location_type_in_traffic_point FOREIGN KEY (location_type_id) REFERENCES location_type(id),
    CONSTRAINT fk_traffic_centre FOREIGN KEY (traffic_centre_id) REFERENCES traffic_centre(id) ON DELETE CASCADE
);

CREATE TABLE walk_type (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    type VARCHAR2(50) UNIQUE NOT NULL
);

CREATE TABLE stop_type (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    type VARCHAR2(50) UNIQUE NOT NULL
);

CREATE TABLE segment (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    destination VARCHAR2(200),
    trip_id NUMBER,
    start_point INTEGER NOT NULL,
    departure_time TIMESTAMP NOT NULL,
    enter_type INTEGER,
    end_point INTEGER NOT NULL,
    arrival_time TIMESTAMP NOT NULL,
    descend_type INTEGER,
    sequence INTEGER NOT NULL,
    CONSTRAINT unique_segment UNIQUE (start_point, end_point, trip_id),
    CONSTRAINT fk_trip_in_segment FOREIGN KEY (trip_id) REFERENCES trip(id) ON DELETE CASCADE,
    CONSTRAINT fk_start_point_in_segment FOREIGN KEY (start_point) REFERENCES traffic_point(id) ON DELETE CASCADE,
    CONSTRAINT fk_enter_type FOREIGN KEY (enter_type) REFERENCES stop_type(id) ON DELETE CASCADE,
    CONSTRAINT fk_end_point_in_segment FOREIGN KEY (end_point) REFERENCES traffic_point(id) ON DELETE CASCADE,
    CONSTRAINT fk_descend_type FOREIGN KEY (descend_type) REFERENCES stop_type(id) ON DELETE CASCADE
);

CREATE TABLE walk (
    id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    min_travel_time NUMBER NOT NULL,
    walk_type_id NUMBER,
    start_point INTEGER NOT NULL,
    end_point INTEGER NOT NULL
    CONSTRAINT unique_walk UNIQUE (start_point, end_point, walk_type),
    CONSTRAINT fk_walk_type FOREIGN KEY (walk_type_id) REFERENCES walk_type(id),
    CONSTRAINT fk_start_point_in_walk FOREIGN KEY (start_point) REFERENCES traffic_point(id) ON DELETE CASCADE,
    CONSTRAINT fk_end_point_in_walk FOREIGN KEY (end_point) REFERENCES traffic_point(id) ON DELETE CASCADE
);

CREATE OR REPLACE TRIGGER segment_ensure_time_with_default_date
    BEFORE INSERT OR UPDATE ON segment
    FOR EACH ROW
BEGIN
    :NEW.departure_time := TO_TIMESTAMP_TZ('1970-01-01 ' || TO_CHAR(:NEW.departure_time, 'HH24:MI') || ':00 ' || TO_CHAR(:NEW.departure_time, 'TZD'), 'YYYY-MM-DD HH24:MI:SS TZD');
    :NEW.arrival_time := TO_TIMESTAMP_TZ('1970-01-01 ' || TO_CHAR(:NEW.arrival_time, 'HH24:MI') || ':00 ' || TO_CHAR(:NEW.arrival_time, 'TZD'), 'YYYY-MM-DD HH24:MI:SS TZD');
END;